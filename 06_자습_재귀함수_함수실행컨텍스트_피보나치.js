// 🟦 재귀함수 

    // 의미 
        // 함수가 자기 자신을 호출하는 함수

    // 예시 
        // render 함수도 재귀함수❓❓❓ 

    // 특징 
        // '알고리즘' 문제 풀 때, 가끔 사용
        // '임시도 데이터 베이스 추가' 할 때 사용

    
    // 예시 
        function add(n) {

            if (n < 5) {
                add (n + 1)
                console.log(n);
            }
        }

        add(0)

        // [실행결과]
            // 4 >> 3 >> 2 >> 1 >> 0 : 이 순서대로 찍힘. 

        // [실행 결과가 왜 거꾸로 나올까?] ⭐⭐⭐ 
            // 구체적인 실행 순서를 보면 
            // 1) 매개변수에 0 이 들어감 > call stack 에 쌓임 
                //  > if (0<5) 이 된다 > add(0 + 1) 이 된다. 
                // 이 순간, 1) console.log() 로 넘어가지 않고 2) add(1) 로 넘어가고 > call stack 에 쌓임
            // 2) 매개변수에 1 가 들어가고  > add(1 + 1) 이 되고 
                // 이 순간 1) console.log() 로 넘어가지 않고, 2) add(2) 로 넘어감. call stack 에 쌓임. 
        
            // 이걸 반복하면, add(0) >> add(1) >> add(2) >> add(3) >> add(4) 의 순서로 1) 실행 되고 2) 함수 실행 컨텍스트가 만들어지고 3) call stack 에 쌓임.             
            // 그런데, 'stack' 알고리즘에서는, '뒤에 쌓인 것' 을 '먼저 실행' > 그래서, 4 > 3 > 2 > 1 > 0 으로 찍힘 

        // [포인트]
            // 개발자 도구 > source 에서 > 필요한 line 에 포인트 찍고 > 새로고침하고, step by step 으로 실행해보면 > call stack 에 쌓이는 걸 볼 수 있음. 
            // call 'stack' 은 '후입 선출'. 
            // '박스에 짐 꺼내기' 생각. 


        // [궁금증]
            // 1. call stack 에 쌓였다는게, 구체적으로 뭐지? ❓❓❓ 
            // 2. 함수가 실행 된 것 같은데, 또 실행된게 아니네? ❓❓❓ 
            // 3. 동일하게 쌓인 데이터를 stack 이 아니라, que 처럼 작동하게 할 수도 있나? 그래야할 필요성이 생길 수도 있나? 

        // [자바스크립트에서 call stack 에 쌓였다는게 뭘 의미해?]
            // 함수가 호출되면 > 함수 실행에 필요한 1) 지역변수 2) 매개변수 3) 반환 주소 같은 정보를 담은 '프레임(frame)' 이, ⭐호출 스택(call stack)⭐ 에 쌓임. 
            // 함수가 '실행' 되면 > 1) '프레임' 이 '스택에서 제거' 되고 2) '제거된 이전 프레임' 으로 '실행 흐름' 이 들아간다. ⭐⭐⭐⭐⭐ 
            
            // 자바스크립트의 호출 스택은 '단일 스레드(Single-Thread)' 로 동작함. 
                // 따라서, '한 번에 하나의 함수'만 실행된다. 
                // 따라서, ⭐함수 호출 중 다른 함수가 호출되면⭐, 실행되지 못 한 다른 함수는 호출 스택에 쌓인다. 
                // '함수 호출 중 다른 함수가 호출' 되는 경우로써, 재귀함수, 반복문 무한 루프가 있음. 
